## 单例模式

### 双重检验锁方式的单例模式

```java
class Singleton {
  	private volatile static Singleton uniqueInstance;
  	//volatile保证不会被指令重排，uniqueInstance = new Singleton()这一步可分为三小步
  	//1.为uniqueInstance分配内存空间
  	//2.初始化uniqueInstance
  	//3.将uniqueInstance指向分配的内存空间
  	//指令重排可能导致执行顺序为1-3-2,会导致一个县城获得还没有初始化的实例。
  	private Singleton() {}
  
  	public static Singleton getInstance() {
      	if(uniqueInstance == null) {//提高性能，省得每次判断都要走同步锁
          	synchronized(Singleton.class) {
              	if(uniqueInstance == null) {//因为可能有多个线程进入同步块外的if，同步块内还需要再判断一次，以保证单例
                  	uniqueInstance = new Singleton();
                }
            }
        }
      	return uniqueInstance;
    }
}
```







## 包装器模式

并发中的Future？

IO中的多层流的包装？



## 工厂模式

线程池的Executor框架

